# 缺省参数
### 1.可以为函数的参数指定缺省值，调用函数时，若未指定实参，则与该实参相对应的形参取缺省值。
### 2.函数的缺省参数是在编译阶段解决的，因此，只能用常量、常量表达式或全局变量等非局部化数值作为缺省参数。
```c++
    int b = 1000; // 全局变量    
    void foo(int a, int b = 1000) { std::cout << a << ' ' << b << std::endl; }  
    void bar(int a = 100 + 900)   { std::cout << a << std::endl; }
    void hum(int a = b)           { std::cout << a << std::endl; }
    // void fun(int a, int b = a) {} // ERROR    

    foo(123, 456);
    foo(123); // foo(123, 1000);
    bar();    // bar(1000);
    hum();    // hum(1000);
```
### 3.如果函数的声明和定义分开书写，那么该缺省参数只能写在声明部分，定义部分不能指定缺省参数，但是可以通过注释提高代码的可读性。  
### 4.如果函数的某一个参数带有缺省值，那么该参数后面的所有参数必须都带有缺省值。
```c++
    void fun(int a, int b = 1000, int c = 2000) { 
        std::cout << a << ' ' << b << ' ' << c << std::endl; 
    }
```
### 5.不要因为使用缺省参数而导致重载歧义。
```c++
    void fun(int a, int b = 1000, int c = 2000) { 
        std::cout << a << ' ' << b << ' ' << c << std::endl; 
    }
    void fun(int a) {
        std::cout << a << std::endl;
    }

    // fun(100); // 调用哪个？ // ERROR
    fun(100, 200); 
    fun(100, 200, 300); 
```
# 哑元
### 1. 只指定类型而不指定名称的函数参数，称之为哑元。
```c++
    void foo(int) {}
    int add(int a, int, int c) { return a + c; }
```
### 2.哑元主要应用于用于版本升级过程中的向下兼容和特殊的操作符重载登场合。
# 内联
### 1.内联就是用函数已经编译好的二进制代码替换对该函数的调用指令。
### 2.内联在保证函数特性的同时，避免来函数调用的开销。通过牺牲代码空间，赢得运行时间。
### 3.内联会使可执行文件的体积和进程代码区的内存变大，因此，只有频繁调用的简单函数才适合内联。稀少被调用的复杂函数，调用开销远小于其执行开销，由内联而获得的时间性能改善不足以抵消空间性能的损失，故不适合内联。
### 4.递归函数不能内联。
### 5.通过inline关键字可以显示地请求编译器将某个函数处理为内联函数。
```c++
    inline double square(double x) { return x * x; }

    std::cout << square(3.0) << std::endl;
    // std::cout << 3.0 * 3.0 << std::endl;
```
### 6.inline关键字仅仅表示一种对函数实施内联优化的期望，但该函数是否真的会被处理为内联，还要看编译器的优化策略决定。
### 7.多数现代编译器已经把内联作为一种缺省的优化机制，即使不是显式使用inline关键字，只要该函数符合内联优化的条件，编译器也会自动将其处理为内联函数。
